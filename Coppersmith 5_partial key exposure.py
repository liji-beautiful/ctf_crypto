from Crypto.Util.number import bytes_to_long
from gmpy2 import next_prime, invert
import os

n=49493809235737584028951067320049943823835967885016479021486823788408059163947029767508318669011656386887629397545802716559050257929902844629960617300132853174328984384211048281626612106906671962273774797431453019676427748515310411660766340699111330002892830139840940740048339817572470046267923220623799193899
output=30220071608507846205041931882033747412461345281150064429974426113141485501457753961828460017939244564745774540924330478785860653644767824985292944887741606822332291702048511499234667599430858687348010127034767466790600640692910594275130631576916500893364848631431724036680925551361217850658534377000592103197
d_low=241798237446811455463307897272988330912051150858327930700633530578387298921238456658890273
e=17
"""
本题是私钥部分泄露的攻击
原理如下：
ed=1+k(p-1)(q-1)
两边同时模1<<512
e*d_low=1+k(n-p-n/p+1)(mod 1<<512)
这时即可解出p的低位且和d的位数一样

以下为sage的代码段:
def find_p(p0):
    PR.<x> = PolynomialRing(Zmod(n))
    f = 2**300*x +p0
    f=f.monic()
    roots = f.small_roots(X=2^224, beta=0.4)
    return(roots[0])


def solve_p0():
    var("x")
    for k in range(1,4):
        res=slove_mod(3*d_low*x-k*x*(n-x+1)+k*n==x,2**300)
        for x in res:
            p0=ZZ(X[0])
            p=find_p(p0)
            if p:
                print(p)


"""
p=6987890884044398820038460674295500979139596011178092920922045246077380957938757185191001250048610021824062826289892308535605296476263347923916984562746053
q=7082796520012620766745503097475303258627133127181272307140021787703967912536545620001959345171079562305167313544454348683795372323435881240938554181665583
d=invert(e,(p-1)*(q-1))
print(pow(output,d,n))
